#!/usr/bin/env tsx
/**
 * Auto-generates docs/TOOLS.md and docs/PERMISSIONS.md from source code.
 *
 * Scans src/tools/*.ts and src/schemas/*.ts for tool definitions and
 * generates documentation tables.
 *
 * Usage: pnpm run docs:generate
 */

import { readFileSync, readdirSync, writeFileSync } from "node:fs";
import { basename, join } from "node:path";

const ROOT = new URL("..", import.meta.url).pathname;
const TOOLS_DIR = join(ROOT, "src/tools");
const SCHEMAS_DIR = join(ROOT, "src/schemas");
const TOOLS_DOC = join(ROOT, "docs/TOOLS.md");
const PERMISSIONS_DOC = join(ROOT, "docs/PERMISSIONS.md");

// Phase mapping per module
const MODULE_PHASES: Record<string, number> = {
  mail: 2,
  calendar: 3,
  files: 4,
  contacts: 5,
  todo: 5,
  teams: 6,
  sharepoint: 6,
};

// Known permission scopes per module
const MODULE_SCOPES: Record<string, string[]> = {
  mail: ["Mail.ReadWrite", "Mail.Send"],
  calendar: ["Calendars.ReadWrite"],
  files: ["Files.ReadWrite"],
  contacts: ["Contacts.ReadWrite"],
  todo: ["Tasks.ReadWrite"],
  teams: ["Teams.ReadWrite", "ChannelMessage.Send"],
  sharepoint: ["Sites.ReadWrite.All"],
};

interface ToolInfo {
  name: string;
  description: string;
  classification: "safe" | "moderate" | "destructive";
  module: string;
  phase: number;
  scopes: string[];
}

/**
 * Extracts tool definitions from a tool module file.
 *
 * Looks for patterns like:
 *   server.tool("tool_name", "description", schema, handler)
 * or exported tool definition objects.
 */
function extractToolsFromFile(filePath: string, moduleName: string): ToolInfo[] {
  const content = readFileSync(filePath, "utf-8");
  const tools: ToolInfo[] = [];

  function addMatch(name: string, description: string) {
    if (!tools.some((t) => t.name === name)) {
      tools.push({
        name,
        description,
        classification: classifyTool(name, content),
        module: moduleName,
        phase: MODULE_PHASES[moduleName] ?? 0,
        scopes: MODULE_SCOPES[moduleName] ?? [],
      });
    }
  }

  // Pattern 1: server.tool("name", "description", ...)
  for (const m of content.matchAll(/server\.tool\(\s*["'](\w+)["']\s*,\s*["']([^"']+)["']/g)) {
    addMatch(m[1], m[2]);
  }

  // Pattern 2: export const TOOL_NAME = { name: "...", description: "..." }
  for (const m of content.matchAll(
    /export\s+const\s+\w+\s*=\s*\{[^}]*name:\s*["'](\w+)["'][^}]*description:\s*["']([^"']+)["']/g,
  )) {
    addMatch(m[1], m[2]);
  }

  // Pattern 3: registerXTools function with tool() calls inside
  for (const m of content.matchAll(/tool\(\s*["'](\w+)["']\s*,\s*["']([^"']+)["']/g)) {
    addMatch(m[1], m[2]);
  }

  return tools;
}

/**
 * Classifies a tool based on its name and surrounding code.
 */
function classifyTool(name: string, fileContent: string): "safe" | "moderate" | "destructive" {
  const destructivePatterns = ["send_", "delete_", "move_", "forward_", "reply_", "share_"];
  const moderatePatterns = ["create_", "update_", "upload_", "copy_"];

  if (destructivePatterns.some((p) => name.startsWith(p))) return "destructive";
  if (moderatePatterns.some((p) => name.startsWith(p))) return "moderate";

  // Check if WriteParams is used near this tool
  const toolSection = fileContent.substring(
    Math.max(0, fileContent.indexOf(name) - 200),
    fileContent.indexOf(name) + 500,
  );
  if (toolSection.includes("WriteParams") || toolSection.includes("confirm")) return "destructive";

  return "safe";
}

/**
 * Generates docs/TOOLS.md content.
 */
function generateToolsMd(tools: ToolInfo[]): string {
  const lines = [
    "# MCP Tools Reference",
    "",
    "<!-- AUTO-GENERATED by scripts/generate-docs.ts â€” DO NOT EDIT MANUALLY -->",
    "",
  ];

  if (tools.length === 0) {
    lines.push("## Implementierte Tools");
    lines.push("");
    lines.push("_Noch keine Tools implementiert. Wird ab Phase 2 befÃ¼llt._");
    lines.push("");
    lines.push("## Tool-Format");
    lines.push("");
    lines.push("Jedes Tool hat:");
    lines.push("- **Name:** snake_case Bezeichner");
    lines.push("- **Description:** FÃ¼r LLM-Auswahl optimierte Beschreibung");
    lines.push("- **Input Schema:** JSON Schema (generiert aus Zod)");
    lines.push("- **Klassifizierung:** safe | moderate | destructive");
    lines.push("");
    lines.push("## Geplante Tools");
    lines.push("");
    lines.push("Siehe Project_Description.md Abschnitte 2.3 und 8 fÃ¼r die vollstÃ¤ndige Liste.");
  } else {
    lines.push("## Implementierte Tools");
    lines.push("");
    lines.push("| Tool | Beschreibung | Modul | Klassifizierung |");
    lines.push("|---|---|---|---|");

    for (const tool of tools) {
      const badge =
        tool.classification === "destructive"
          ? "ðŸ”´ destructive"
          : tool.classification === "moderate"
            ? "ðŸŸ¡ moderate"
            : "ðŸŸ¢ safe";
      lines.push(`| \`${tool.name}\` | ${tool.description} | ${tool.module} | ${badge} |`);
    }

    lines.push("");
    lines.push(`_${tools.length} Tools registriert._`);
  }

  lines.push("");
  return lines.join("\n");
}

/**
 * Generates docs/PERMISSIONS.md content.
 */
function generatePermissionsMd(tools: ToolInfo[]): string {
  const lines = [
    "# Microsoft Graph API Permissions",
    "",
    "<!-- AUTO-GENERATED by scripts/generate-docs.ts â€” DO NOT EDIT MANUALLY -->",
    "",
  ];

  // Scope â†’ Tools mapping
  const scopeTools = new Map<string, string[]>();

  for (const tool of tools) {
    for (const scope of tool.scopes) {
      const existing = scopeTools.get(scope) ?? [];
      existing.push(tool.name);
      scopeTools.set(scope, existing);
    }
  }

  lines.push("## MVP Scopes (Delegated)");
  lines.push("");
  lines.push("| Scope | BegrÃ¼ndung | Tools |");
  lines.push("|---|---|---|");

  // Static scopes that are always present
  const staticScopes: [string, string][] = [
    ["Mail.ReadWrite", "E-Mails lesen, verschieben, lÃ¶schen"],
    ["Mail.Send", "E-Mails senden, antworten, weiterleiten"],
    ["Calendars.ReadWrite", "Kalender lesen und Termine erstellen/Ã¤ndern"],
    ["Files.ReadWrite", "OneDrive Dateien lesen und schreiben"],
    ["Contacts.ReadWrite", "Kontakte verwalten"],
    ["Tasks.ReadWrite", "To Do Aufgaben verwalten"],
    ["User.Read", "Eigenes Profil lesen"],
  ];

  for (const [scope, reason] of staticScopes) {
    const toolList =
      scopeTools
        .get(scope)
        ?.map((t) => `\`${t}\``)
        .join(", ") || "â€”";
    lines.push(`| ${scope} | ${reason} | ${toolList} |`);
  }

  lines.push("");
  lines.push("## Tool-Presets");
  lines.push("");
  lines.push("### readonly");
  lines.push("Mail.Read, Calendars.Read, Files.Read, Contacts.Read, Tasks.Read, User.Read");
  lines.push("");
  lines.push("### mvp");
  lines.push(
    "Mail.ReadWrite, Mail.Send, Calendars.ReadWrite, Files.ReadWrite, Contacts.ReadWrite, Tasks.ReadWrite, User.Read",
  );
  lines.push("");
  lines.push("### full");
  lines.push("Alle MVP-Scopes + Teams.ReadWrite, Sites.ReadWrite.All, ChannelMessage.Send");
  lines.push("");

  return lines.join("\n");
}

// --- Main ---

function main() {
  console.log("ðŸ“„ Generating docs from source...");

  const allTools: ToolInfo[] = [];

  // Scan tool files
  const toolFiles = readdirSync(TOOLS_DIR).filter((f) => f.endsWith(".ts"));

  for (const file of toolFiles) {
    const moduleName = basename(file, ".ts");
    const filePath = join(TOOLS_DIR, file);
    const tools = extractToolsFromFile(filePath, moduleName);
    allTools.push(...tools);
  }

  console.log(`   Found ${allTools.length} tools in ${toolFiles.length} modules`);

  // Generate TOOLS.md
  const toolsMd = generateToolsMd(allTools);
  writeFileSync(TOOLS_DOC, toolsMd, "utf-8");
  console.log("   docs/TOOLS.md updated");

  // Generate PERMISSIONS.md
  const permsMd = generatePermissionsMd(allTools);
  writeFileSync(PERMISSIONS_DOC, permsMd, "utf-8");
  console.log("   docs/PERMISSIONS.md updated");

  console.log("ðŸ“„ Done.");
}

main();
